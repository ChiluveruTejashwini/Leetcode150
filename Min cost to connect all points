class Solution:
    def minCostConnectPoints(self, points: List[List[int]]) -> int:
        n = len(points)

        # Initialize a min-heap and start with the first point (cost = 0)
        heap = [(0, 0)]  # (cost, point_index)
        visited = [False] * n  # To track visited points
        total_cost = 0
        edges_used = 0  # To keep track of the edges used
        
        while heap and edges_used < n:
            cost, point = heapq.heappop(heap)  # Get the smallest cost point
            if visited[point]:
                continue  # Skip if this point has already been visited
            
            visited[point] = True  # Mark the current point as visited
            total_cost += cost  # Add the cost to the total cost
            edges_used += 1  # Increase the number of edges used
            
            for i in range(n):
                if not visited[i]:
                    manhattan_distance = abs(points[point][0] - points[i][0]) + abs(points[point][1] - points[i][1])
                    heapq.heappush(heap, (manhattan_distance, i))
        
        return total_cost
poi= [[0,0],[2,2],[3,3],[2,4],[4,2]]       
print(Soution().minCostConnectPoints(poi))
