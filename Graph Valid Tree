class Solution:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != (n - 1):
            return False

        di = defaultdict(list)
        
        for u,v in edges:
            di[u].append(v)
            di[v].append(u)
        visit=set()

        def dfs(node,par):
            visit.add(node)
            for neigh in di[node]:
                if neigh == par:
                    continue
                if neigh not in visit:
                    dfs(neigh,node)
                elif neigh in visit:
                    return False
            return True
        return dfs(0,-1)

class Solution2:
    def validTree(self, n: int, edges: List[List[int]]) -> bool:
        if len(edges) != (n - 1):
            return False

        di = defaultdict(list)
        
        for u,v in edges:
            di[u].append(v)
            di[v].append(u)
        visited=set()

        queue=deque([(0,-1)])
        visited.add(0)

        while queue:
            node, parent=queue.popleft()
            visited.add(node)
            for neigh in di[node]:
                if neigh==parent:
                    continue
                elif neigh not in visited:
                    queue.append((neigh,node))
                else:
                    return False
                
        return True

        
n = 5
edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]
print(Solution().validTree(n,edges))
print(Solution2().validTree(n,edges))


        
        
        


                

        
        

        
